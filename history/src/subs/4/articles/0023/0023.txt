<article>
	<div><header class="w3-header"><p>理解 Java 中的弱引用</p></header></div>
	<div><img class="w3-width" alt="Oops" src="src/subs/4/articles/0023/images/01.jpg" /></div>
	<div><p><span class="w3-text-blue">强引用</span>，我们经常使用的引用就是强引用，写法如下所示：</p></div>
	<div class="w3-custom-code" style="text-align:center">
		<pre>StringBuffer buffer = new StringBuffer();</pre>
	</div>
	<div><p>上述代码创建了一个 StringBuffer 对象，将这个对象的（强）引用存储到变量 buffer 内。强引用最重要的就是它能够让引用变得强（Strong），这就决定了它和垃圾回收器的交互。具体来说，如果一个对象通过<span class="w3-text-light-green">强引用链</span>可达（Strongly Reachable），那么它是不会被回收的。如果你不想让你正在使用的对象被回收，使用强引用就是你需要做的事。</p></div>
	<div><p>强引用可能会导致的问题：</p></div>
	<div><p>在一个程序里，将一个类设置成不可被扩展是有点不太常见的，当然，这个完全可以通过将类标记成 final 实现。或者，也可以更加复杂一些，就是通过内部实现的工厂方法返回一个接口（Interface）。举例说明，我们想要使用一个 Widget 的类，但是这个类不能被继承，所以无法增加新的功能。</p></div>
	<div><p>但是，我们如果想要追踪 Widget 对象的额外信息，我们该怎么办？假设我们需要记录每个对象的序列号，由于 Widget 类并不包含这个属性，而且该类也不能扩展，这导致我们也不能增加新的属性。令人欣慰，HashMap 完全可以解决上述问题：</p></div>
	<div class="w3-custom-code" style="text-align:center">
		<pre>serialNumberMap.put(widget, widgetSerialNumber);</pre>
	</div>
	<div><p>然而，这在表面上看来没有问题，但是，Widget 对象的<span class="w3-text-light-green">强引用</span>很有可能会引发问题。我们可以确信，当一个 Widget 序列号不再需要时，我们应该将这个条目从 map 中移除。但是，如果我们没有移除的话，可能会导致内存泄露，亦或是我们手动移除时删除了我们正在使用的 Widget 对象，这会导致有效数据的丢失。</p></div>
	<div><p><span class="w3-text-light-green">另一个强引用可能带来的问题</span>就是缓存，尤其是像图片这样的大文件的缓存。假设你有一个程序需要处理用户提供的图片，通常的做法就是将图片数据缓存，因为从磁盘加载图片代价很大，并且，我们也还想避免在内存中同时存在两份一样的图片数据。</p></div>
	<div><p>设计缓存的目的是避免我们重复加载数据，然而，你会很快发现在缓存中会一直包含一个指向内存中的图片数据的引用。使用强引用会强制图片数据驻留内存，这就需要你来确定图片数据的失效时间并手动从缓存中移除，进而可以让垃圾回收器回收。因此，你再次被强制要求做垃圾回收器该做的工作，并且需要人为确定是该清理哪一个对象。</p></div>
	<div><p><span class="w3-text-blue">弱引用</span>的简要介绍和使用：</p></div>
	<div><p>弱引用，简而言之，就是<span class="w3-text-light-green">对象留在内存的能力不是那么强的引用</span>。使用 WeakReference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存中移除。创建弱引用，如下所示：</p></div>
	<div class="w3-custom-code" style="text-align:center">
		<pre>WeakReference&lt;Widget&gt; weakWidget = new WeakReference&lt;Widget&gt;(widget);</pre>
	</div>
	<div><p>使用 weakWidget.get() 就可以得到真实的 Widget 对象，因为弱引用不能阻挡垃圾回收器对它进行回收，你会发现（当没有任何强引用到 Widget 对象时）使用 get 时，存在突然返回 null 的情况。</p></div>
	<div><p>解决上述的 Widget 序列数记录的问题，最简单的办法就是使用 Java 内置的 WeakHashMap 类。WeakHashMap 和 HashMap 几乎一样，唯一的区别就是它的键使用了 WeakReference 引用。当 WeakHashMap 的键被标记为垃圾的时候，这个键对应的条目就会自动被移除。这就避免了上面不需要的 Widget 对象手动删除的问题。使用 WeakHashMap 可以很便捷地转换为 HashMap 或 Map 。</p></div>
	<div><p><span class="w3-text-blue">软引用</span>的简要介绍和特性：</p></div>
	<div><p>软引用基本上和弱引用差不多，只是相比弱引用而言，它阻止垃圾回收期内回收其指向的对象的能力强一些。如果一个对象是弱引用可达，那么这个对象会被垃圾回收器接下来的回收周期销毁。但是，如果是软引用可达，那么，这个对象驻留于内存的时间会更长一些。当内存不足时，垃圾回收器才会回收这些软引用可达的对象。</p></div>
	<div><p>由于软引用可达的对象比弱引用可达的对象滞留内存的时间更长，我们可以<span class="w3-text-light-green">利用这个特性来做缓存</span>。这样的话，你就可以节省很多事情，垃圾回收器会关心当前哪种可达类型以及根据内存的消耗程度进行相应的处理。</p></div>
	<div><p><span class="w3-text-blue">虚引用</span>的简要介绍和使用：</p></div>
	<div><p>与软引用、弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过 get 方法来得到其指向的对象。它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用于记录该引用指向的对象已被销毁。</p></div>
	<div><p>当弱引用的指向对象变得弱引用可达时，该弱引用就会加入到引用队列。这一操作发生在对象析构或垃圾回收真正发生之前。理论上，这个即将被回收的对象是可以在一个不符合规范的析构方法里面重新复活的。但是，这个弱引用会销毁。然而，虚引用只有在其指向的对象从内存中移除掉之后才会加入到引用队列中，其 get 方法一直返回 null 就是为了阻止其指向的几乎被销毁的对象重新复活。</p></div>
	<div><p>虚引用的使用场景主要由两个：第一，它允许你知道具体何时将其引用的对象从内存中移除，实际上这是 Java 中唯一的方式，这一点尤其表现在处理类似图片的大文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后再继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错误。</p></div>
	<div><p>第二，虚引用可以避免很多析构时的问题。finalize 方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了 finalize 方法的对象如果想要被回收掉，是需要经历两个单独的垃圾回收周期的。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是，因为在析构过程中仍有微弱的可能会导致这个对象重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以，在调用对象的析构之前，就需要经历数量不确定的垃圾回收周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会出现可恶的内存溢出错误。</p></div>
	<div><p>使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个已销毁的对象。因为这个时候，对象已经从内存中销毁。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。</p></div>
	<div><p>显而易见，finalize 方法不建议被重写。因为虚引用明显地安全高效，去掉 finalize 方法可以让虚拟机变得明显简单。当然，你也可以去重写这个方法来实现更多功能。这完全看个人的选择。</p></div>
	<div><p>简要介绍引用队列的意义：</p></div>
	<div><p>一旦弱引用对象开始返回 null，该弱引用指向的对象就被标记成为垃圾，此后，这个弱引用对象就没有什么用了。通常，这时候需要进行一些清理工作。比如 WeakHashMap 会在这时候移除没有用的条目来避免保存无限制增长的没有意义的弱引用。</p></div>
	<div><p>引用队列可以很容易地实现跟踪不需要的引用。当你在构造 WeakReference 时，传入一个 ReferenceQueue 对象，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期内处理传入的引用队列，比如，做一些清理工作来处理这些没有用的引用对象。</p></div>
	<div><p>给出四中引用的排列次序：Java 语言有四种强度不同的引用，它们从强到弱分别是，强引用、软引用、弱引用和虚引用。<a target="_blank" class="w3-link" href="https://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/">原文链接</a></p></div>
	<div><p></p></div>
</article>