<article>
	<div><p><strong>Java 并发编程系列：ThreadPoolExecutor 初探（15）</strong></p><p class="w3-right">2017-12-31</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadPoolExecutor，顾名思义，简单理解为，这是一个用以管理、维护线程的线程池，它与数据库连接池的应用可谓异曲同工，虽然两者管理、维护的对象不同，但核心思想是一致的，即重复使用现有对象以降低因创建、销毁对象等操作所占用的系统资源，从而提升业务处理能力。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/39.txt',id:'prevtonext'},{url:'src/area_2/articles/0040/0040.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>CSS + JS 实现简易版扫雷</strong></p><p class="w3-right">2017-12-25</p></div>
	<div style="clear: both;"></div>
	<div class="w3-example-mine-sweeping-01-02_0039">
		<script>
			(function(){var cols=6;var rows=6;var node=document.getElementsByClassName("w3-example-mine-sweeping-01-02_0039")[0];var arrx=[];var arry=[];var bool=false;for(let col=1;col<=cols;col++){var coln=document.createElement("div");coln.setAttribute("class","cols");arrx[col-1]=[];arry[col-1]=[];for(let row=1;row<=rows;row++){var wrap=document.createElement("div");wrap.setAttribute("class","wrap");var item=document.createElement("div");item.setAttribute("class","item");arry[col-1][row-1]=item;var back=document.createElement("div");back.style.transform="translate(0,-52px)";back.setAttribute("class","back");back.addEventListener("click",function(){if(bool){show();setTimeout(function(){cler();load(rand());},500);bool = false;}});item.addEventListener("click",function(){if(this.nextSibling.className.indexOf("mine")==-1){this.className+=" hide";}else{hide();bool=true;}});wrap.appendChild(item);wrap.appendChild(back);coln.appendChild(wrap);arrx[col-1][row-1]=back;}node.appendChild(coln);}
				load(rand());
				function show(){for(let col=1;col<=cols;col++){for(let row=1;row<=rows;row++){if(arry[col-1][row-1].className.indexOf("hide")==-1)continue;arry[col-1][row-1].className=arry[col-1][row-1].className.replace(" hide","");}}}
				function hide(){for(let col=1;col<=cols;col++){for(let row=1;row<=rows;row++){if(arry[col-1][row-1].className.indexOf("hide")>-1)continue;arry[col-1][row-1].className+=" hide";}}}
				function rand(){var r=[];var x=Math.floor(Math.random()*10)%5+1;for(let i=0;i<x;i++){var y=Math.floor(Math.random()*100)%36+1;r.push(y);}return r;}
				function load(arrz){for(let col=1;col<=cols;col++){for(let row=1;row<=rows;row++){if(jude(arrz,(row-1)*6+col)){if(arrx[col-1][row-1].className.indexOf("mine")>-1)break;arrx[col-1][row-1].className+=" mine";}}}}
				function jude(arrz,t){for(let n=0;n<arrz.length;n++){if((arrz[n]==t)){return true;}}return false;}
				function cler(){for(let col=1;col<=cols;col++){for(let row=1;row<=rows;row++){arrx[col-1][row-1].className=arrx[col-1][row-1].className.replace(" mine","");}}}
			})();
		</script>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/38.txt',id:'prevtonext'},{url:'src/area_2/articles/0039/0039.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>面包屑导航（Breadcrumb Navigation）</strong></p><p class="w3-right">2017-12-24</p></div>
	<div style="clear: both;"></div>
	<div class="w3-example-breadcrumb-navigation-01-02_0038">
		<div>
			<a>首页</a><a>关于</a><a>职业提升</a><a>生活随笔</a>
		</div>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/37.txt',id:'prevtonext'},{url:'src/area_2/articles/0038/0038.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Java 并发编程系列：ReentrantLock 之源码调试（14）</strong></p><p class="w3-right">2017-12-16</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在阅读过同行从业者写的关于 AQS（AbstractQueuedSynchronizer）知识点的博文之后，根据理论加以实践是必不可少的，还是那句话：<span class="w3-text-light-green">纸上得来终觉浅，绝知此事要躬行</span>。</P>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇文章主要是借助 eclipse 开发工具对 JDK1.8 源码之 ReentrantLock 进行调试，以理解基于 AQS 的独占功能的实现过程。</P>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/36.txt',id:'prevtonext'},{url:'src/area_2/articles/0037/0037.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Java 并发编程系列：<span class="w3-text-light-green">转载</span> --- JDK1.8 AbstractQueuedSynchronizer 的实现分析（下）</strong></p><p class="w3-right">2017-12-11</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过本系列的上半部分 <a target="_blank" class="w3-link" href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer">JDK1.8 AbstractQueuedSynchronizer 的实现分析（上）</a>的解读，相信很多读者对 AbstractQueuedSynchronizer 的独占功能已了然于胸，趁热打铁，这次我们通过对另一个工具类：CountDownLatch 的分析来解读 AQS 的另外一个功能：共享功能。</P>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/35.txt',id:'prevtonext'},{url:'src/area_2/articles/0036/0036.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Java 并发编程系列：<span class="w3-text-light-green">转载</span> --- JDK1.8 AbstractQueuedSynchronizer 的实现分析（上）</strong></p><p class="w3-right">2017-12-08</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，ReentrantLock 的功能是实现代码段的并发访问控制，也就是通常意义上所说的锁，在没有看到 AbstractQueuedSynchronizer 之前，你可能会以为它的实现是通过类似于 synchronized，通过给对象加锁来实现的。但事实上，它只是一个工具类，仅是作为一个普普通通的类就完成了代码块的并发访问控制，这就让人疑惑它怎么实现的代码块的并发访问控制的。文中将以 AQS 代替 AbstractQueuedSynchronizer 。</P>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/34.txt',id:'prevtonext'},{url:'src/area_2/articles/0035/0035.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Java 并发编程系列：ThreadLocal（13）</strong></p><p class="w3-right">2017-11-13</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one has its own, independently initialized copy of the variable.</P>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述英文源自 JDK1.8 官方文档里对 ThreadLocal 的介绍，博主试图这样翻译：</P>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal 类用以提供<span class="w3-text-light-green">线程-本地</span>变量，这些<span class="w3-text-light-green">线程-本地</span>变量与它们的常规副本的区别是，每一个线程都只能访问它自身拥有的<span class="w3-text-light-green">线程-本地</span>变量，且该<span class="w3-text-light-green">线程-本地</span>变量独立于变量的初始化拷贝。</P>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然勉强翻译出了字面意思，但个人对英文源句还是不知所云，没关系，直接给出一个代码示例，通过观察执行结果，疑问将豁然开朗。</P>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/33.txt',id:'prevtonext'},{url:'src/area_2/articles/0034/0034.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Java 并发编程系列：<span class="w3-text-light-green">转载</span> --- 克雷格.兰丁&amp;hagersten (CLH Lock)</strong></p><p class="w3-right">2017-11-12</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CLH lock is Craig, Landin, and Hagersten (CLH) locks, CLH lock is <span class="w3-text-light-green">a spin lock</span>, can ensure no hunger, provide fairness <span class="w3-text-light-green">first come first service</span>.</P>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The CLH lock is a scalable, high performance, fairness and spin lock <span class="w3-text-light-green">based on the list</span>, the application thread spin only on a local variable, it constantly polling the precursor state, if it is found that the pre release lock end spin.</P>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/32.txt',id:'prevtonext'},{url:'src/area_2/articles/0033/0033.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Java 并发编程系列：ConcurrentHashMap 续篇（12）</strong></p><p class="w3-right">2017-11-09</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap 初探之后遗留了很多问题，深感 JDK1.8 版本的 ConcurrentHashMap 实现之复杂性，现简要整理一下 CAS（Compare And Swap，即比较并交换）的相关知识点。</P>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/31.txt',id:'prevtonext'},{url:'src/area_2/articles/0032/0032.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Java 并发编程系列：ConcurrentHashMap 初探（11）</strong></p><p class="w3-right">2017-10-28</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记得之前在整理 HashMap 相关知识点的时候，顺带查看了官方文档里对 Hashtable 的描述，于是就看到了以下内容：</P>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... If a thread-safe highly-concurrent implementation is desired, then it is recommended to <span class="w3-text-light-green">use ConcurrentHashMap in place of Hashtable</span>.</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实话实说，虽然 HashMap 已烂熟于心，但到目前为止，个人对 <span class="w3-text-light-green">ConcurrentHashMap</span> 这个在 Java 并发编程的世界里早就声名远播的类还是感到十分陌生，这是很难为情的事，为了不偏科，现亡羊补牢。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/30.txt',id:'prevtonext'},{url:'src/area_2/articles/0031/0031.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>