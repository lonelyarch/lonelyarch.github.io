<article>
	<div><p><strong>SSO 单点登录系列：CAS 之实现原理（02）</strong></p><p class="w3-right">2018-04-13</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在演示过 SSO 单点登录的基本功能之后<samp>，</samp>再根据 CAS 的样例工程 cas-server-3.5.2、cas-client-3.5.0 探究一下其内部实现原理。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/60.txt',id:'prevtonext'},{url:'src/area_2/articles/2018/04/01/01.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>SSO 单点登录系列：HelloWorld（01）</strong></p><p class="w3-right">2018-04-02</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的工作中<samp>，</samp>本人有参与到 SSO 单点登录的相关开发<samp>，</samp>主要是在 CAS（Central Authentication Service）开源框架的基础上将 SSO 客户端内嵌入 Web 应用以实现访问 SSO Server 的目的。现简要整理一下涉及 CAS 开源框架的个别知识点<samp>，</samp>也算是工作经验总结。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/59.txt',id:'prevtonext'},{url:'src/area_2/articles/0060/0060.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>模拟 HttpServer 系列：将 BIO 模式改造为 NIO 模式（04）</strong></p><p class="w3-right">2018-03-29</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查阅文档可知<samp>，</samp>Tomcat 8.0 支持 3 种运行模式<samp>，</samp>即 BIO 模式、NIO 模式以及 APR 模式。前两种模式所使用的技术相对比较熟悉<samp>，</samp>即阻塞式 IO 和非阻塞式 IO<samp>，</samp>至于 APR 模式的详细信息请参阅 <a target="_blank" class="w3-link" href="http://tomcat.apache.org/tomcat-8.0-doc/apr.html">Apache Portable Runtime (APR) based Native library for Tomcat</a> 文档。</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了探究 Tomcat 8.0 源码中 NIO 模式的部分处理细节<samp>，</samp>现将 HttpServer 改造为 NIO 模式下的技术实现。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/58.txt',id:'prevtonext'},{url:'src/area_2/articles/0059/0059.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>模拟 HttpServer 系列：启用线程池（03）</strong></p><p class="w3-right">2018-03-27</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了提升 HttpServer 的并发处理能力<samp>，</samp>现添加线程池。</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Tomcat 8.0 的源码中<samp>，</samp>其内部是实现了 ThreadPoolExecutor 类并以此创建了 worker 线程池<samp>，</samp>但这也只是在 JDK 提供的 ThreadPoolExecutor 类的基础上进行的简单封装。我们直接使用 JDK 的 ThreadPoolExecutor 类创建线程池即可。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/57.txt',id:'prevtonext'},{url:'src/area_2/articles/0058/0058.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>模拟 HttpServer 系列：接收表单数据（02）</strong></p><p class="w3-right">2018-03-26</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 GET 方式发起请求时<samp>，</samp>请求参数通常会拼在 URL 地址内<samp>，</samp>获取参数也比较简单<samp>，</samp>现重点关注如何获取表单数据即 POST 请求参数。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/56.txt',id:'prevtonext'},{url:'src/area_2/articles/0057/0057.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>模拟 HttpServer 系列：HelloWorld（01）</strong></p><p class="w3-right">2018-03-25</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了能够更加透彻地理解 Java Web 服务器的工作原理<samp>，</samp>个人打算基于 JDK1.8 实现一个简单的 HttpServer<samp>，</samp>本着实践出真知的信念不断 coding<samp>，</samp>永无止境。</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别说明：先以最简单、最熟悉的方式入手<samp>，</samp>然后循序渐进地自我完善。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/55.txt',id:'prevtonext'},{url:'src/area_2/articles/0056/0056.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>Tomcat 8.0 之工作原理</strong></p><p class="w3-right">2018-03-21</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tomcat 是一个免费且开放源码的 Web 应用服务器<samp>，</samp>主要用以处理 JSP 和 Servlet<samp>，</samp>也可以处理诸如 HTML 等静态资源<samp>，</samp>但性能不比 Apache 或 Nginx 服务器。现简单介绍一下 Tomcat 8.0 之工作原理。</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别说明：在理解 Tomcat 8.0 之工作原理之前<samp>，</samp>最好对 Java 语言的线程池（ThreadPoolExecutor）的实现原理有清晰的认识<samp>，</samp>在此基础上再去理解 Tomcat 8.0 之工作原理将变得轻车熟路。对 ThreadPoolExecutor 比较陌生的童鞋请翻看博主之前贴出的文章。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/54.txt',id:'prevtonext'},{url:'src/area_2/articles/0055/0055.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong><span class="w3-text-light-green">转载</span> --- 透彻的掌握 Spring 中 @transactional 的使用</strong></p><p class="w3-right">2018-03-20</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务管理是应用系统开发中必不可少的一部分。Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为编码式和声明式两种方式。编程式事务指的是通过编码方式实现事务<samp>；</samp>声明式事务基于 AOP<samp>，</samp>将具体业务逻辑与事务处理解耦。声明式事务管理使业务代码逻辑不受污染<samp>，</samp>因此在实际使用中声明式事务用的比较多。声明式事务有两种方式<samp>，</samp>一种是在配置文件（xml）中做相关的事务规则声明<samp>，</samp>另一种是基于 @Transactional 注解的方式。注释配置是目前流行的使用方式<samp>，</samp>因此本文将着重介绍基于 @Transactional 注解的事务管理。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/53.txt',id:'prevtonext'},{url:'src/area_2/articles/0054/0054.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>SpringMVC 系列：模拟 SpringMVC 中的过滤器处理流程（08）</strong></p><p class="w3-right">2018-03-17</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 HTML 中的 form 表单只支持 GET、POST 请求<samp>，</samp>为了使基于 SpringMVC 的 Web 应用支持 PUT、DELETE 请求<samp>，</samp>我们可以在 web.xml 文件中添加 HiddenHttpMethodFilter 达到该目的。在默认配置下<samp>，</samp>当我们发起的请求包含中文时<samp>，</samp>后台处理该请求时可能会有乱码产生<samp>，</samp>解决该问题的办法通常也是在 web.xml 文件中添加 CharacterEncodingFilter 。</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么 Web 应用中的过滤器是如何工作的呢？现简单模拟一下 Web 应用中过滤器的大致处理流程以及基于责任链模式（Chain of Responsibility Pattern）的过滤器实现。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/52.txt',id:'prevtonext'},{url:'src/area_2/articles/0053/0053.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>
<hr style="border: none; border-top: 1px dotted white;">
<article>
	<div><p><strong>SpringMVC 系列：Visitor Pattern（07）</strong></p><p class="w3-right">2018-03-16</p></div>
	<div style="clear: both;"></div>
	<div class="w3-container w3-light-gray">
		<p><strong>前言：</strong></p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 SpringMVC 框架中存在着诸多设计模式<samp>，</samp>例如<samp>，</samp>单例模式、适配器模式、责任链模式以及访问者模式等<samp>，</samp>当然<samp>，</samp>MVC 模式是显而易见的。因阅读了处理 Java class 文件的源码时遭遇访问者模式<samp>，</samp>现再次整理一下该知识点。</p>
	</div>
	<div><p>……</p></div>
	<div><p style="text-align: right;"><a onclick="initl();fetch([{url:'src/area_2/prevtonext/51.txt',id:'prevtonext'},{url:'src/area_2/articles/0052/0052.txt',id:'contents'}]);" href="javascript:void(0);" class="w3-text-blue" style="text-decoration: none;">继续阅读 »</a></p></div>
</article>