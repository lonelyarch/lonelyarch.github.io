<article>
	<header><h3>一个有关算法问题的思考过程</h3><h4 class="w3-right w3-margin-0"><i class="fa fa-calendar-o"></i> 2017-02-21</h4></header>
    <div style="clear: both;"></div>
    <hr style="margin-top: 0;">
    <div class="w3-panel w3-light-gray" style="border-radius: 10px;">
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近两天遇到一个比较棘手的算法问题，现给出问题的描述（原题为英文版）：</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Kiwiland 这个地方的城镇之间有铁路运营服务，出于经济考虑，所有的轨道都是“单向”的，例如，存在一条从 Kaitaia 到 Invercargill 运营线路不意味着一定会有一条从 Invercargill 到 Kaitaia 的运营线路，实际上，即使存在这样的往返线路，这两条线路也是相对独立的，例如，从 A 镇到 B 镇的线路长为 8，从 B 镇到 A 镇的线路长可能为 6。</p>
        <P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该问题的目的是帮助当地铁路部门向旅客们提供运营线路的相关信息，例如，一条确定线路的距离、两镇之间所有可达线路的总数以及两镇之间最短可达线路等。</P>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>输入：</strong>一个有向图，结点表示城镇，边表示两镇之间的运营线路，边权表示线路距离。给定的直达线路绝不重复且起点站与终点站不为同一城镇，即两镇之间的直达线路只有一条且表示城镇的结点无自环。</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>输出：</strong>对测试题 1 至 5 而言，如果不存在这样的线路，输出 "NO SUCH ROUTE"，否则，给出线路距离。例如，第一个问题的意思是，以 A 城镇为起点站，途经 B 城镇（A、B 两镇的距离为 5）再抵达 C 城镇（B、C 两镇的距离为 4）。</p>
        <ul style="list-style-type: decimal; padding-left: 50px;">
            <li><p>线路 A-B-C 的距离。</p></li>
            <li><p>线路 A-D 的距离。</p></li>
            <li><p>线路 A-D-C 的距离。</p></li>
            <li><p>线路 A-E-B-C-D 的距离。</p></li>
            <li><p>线路 A-E-D 的距离。</p></li>
            <li><p>以 C 为起点站也为终点站（不含自环）且途经最多 2 站的所有线路总数。以下列测试数据为依据，有 2 条这样的线路：C-D-C（途经 D 站）和 C-E-B-C（途经 E、B 站）。</p></li>
            <li><p>以 A 为起点站、C 为终点站且途经 3 站的所有线路总数。以下列测试数据为依据，有 3 条这样的线路：A 到 C（途经 B、C、D 站）、A 到 C（途经 D、C、D 站）以及 A 到 C（途经 D、E、B 站）。</p></li>
            <li><p>A 至 C 的最短线路长。</p></li>
            <li><p>B 至 B 的最短线路长。</p></li>
            <li><p style="word-wrap: break-word;">C 至 C 的线路长少于 30 的所有不同线路数。以下列测试数据为依据，这些线路为：CDC，CEBC，CEBCDC，CDCEBC，CDEBC，CEBCEBC，CEBCEBCEBC。</p></li>
        </ul>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>测试输入：</strong></p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对测试输入而言，以字母表前几个字母 A 至 E 命名城镇，两镇之间的线路距离（例如，A 至 B 的距离为 5）用 AB5 表示。</p>
        <p style="word-wrap: break-word;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图：AB5，BC4，CD8，DC8，DE6，AD5，CE2，EB3，AE7（<strong style="color: red;">测试数据</strong>）。如图所示：</p>
        <img alt="赋权图" src="src/articles/02/02_2/images/0009_1.jpg" style="max-width: 100%; max-height: 100%; padding: 0 30px;" />
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博主在看完题目之后最先想到的是在算法思想上妇孺皆知的<strong>迪杰斯特拉（Dijkstra）算法</strong>以及图论的相关内容，可惜，远离学生时代的几载春秋之后，它们的内在美于博主的记忆里已经是面目全非……</p>
    </div>
    <div class="w3-panel w3-custom-color" style="border-radius: 10px;">
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对上述题目，博主用了几乎两天时间潜心复习了《数据结构》里图的相关内容，有向赋权图的概念、深度优先搜索、广度优先搜索等等，可惜拙于天分，最终还是凭借强大的百度搜索解决了该题，不过，在几经烧脑之后，博主对该题有了新的算法实现，现记录一下自己的解题过程、想法以及答案：</p>
        <ul style="list-style-type: decimal; padding-left: 50px;">
            <li>
                <p>苦于良策久之，博主无意间想起了曾经解答过一个类似的含有邻接矩阵思想的问题，该问题考察的核心点就是用代码实现数学里的排列组合，现给出之前已有的代码，如下所示：</p>
                <div style="margin-left: -20px; margin-right: 35px;">
                    <img alt="排列算法" src="src/articles/02/02_2/images/0009_3.jpg" style="max-width: 100%; max-height: 100%;" />
                </div>
                <div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
                    <h4 style="word-wrap: break-word;">对 A，B，C，D，E 进行排列实现：</h4>
                    <div class="w3-code" style="height: 300px; overflow-y: auto;">
                        <pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 排列：从 5 个字母里选择 1 个字母、2 个字母、3 个字母、4 个字母、5 个字母</span>
        <span class="hljs-comment">// k 为选择字母的个数（编码习惯，没有将 k 初值设置为 1，即 k=0 表示选择 1 个字母，以此类推）</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) {
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    list.add(arr[i]);
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) {
                        <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).length() == k &amp;&amp; !list.<span class="hljs-keyword">get</span>(i).contains(arr[j])) {
                            <span class="hljs-comment">// 去重判断</span>
                            <span class="hljs-keyword">if</span> (list.contains(list.<span class="hljs-keyword">get</span>(i) + arr[j])) {
                                <span class="hljs-keyword">continue</span>;
                            }
                            list.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                        }
                    }
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            }
        }
    }
}</code></pre>
					</div>
				</div>
            </li>
            <li>
                <p style="word-wrap: break-word;">在实现 A，B，C，D，E 的全排列之后，对上述代码稍加修改就可对有向图<strong style="color: red;">以邻接矩阵为线索</strong>进行全排列（可视之为<strong style="color: red;">广度优先搜索</strong>），步骤 1 的改进代码如下所示：</p>
                <div style="margin-left: -20px; margin-right: 35px;">
                    <img alt="排列算法" src="src/articles/02/02_2/images/0009_4.jpg" style="max-width: 100%; max-height: 100%;" />
                </div>
                <div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
                    <h4>以邻接矩阵为线索对有向图进行全排列实现：</h4>
                    <div class="w3-code" style="height: 300px; overflow-y: auto;">
                        <pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;
        <span class="hljs-keyword">int</span>[][] ars = {
                {<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}}; <span class="hljs-comment">// 邻接矩阵（adjacency-matrix）</span>

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 排列：从 5 个字母里选择 1 个字母、2 个字母、3 个字母、4 个字母、5 个字母</span>
        <span class="hljs-comment">// k 为选择字母的个数（编码习惯，没有将 k 初值设置为 1，即 k=0 表示选择 1 个字母，以此类推）</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) { 
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    list.add(arr[i]);
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).length() == k) {
                        <span class="hljs-keyword">char</span> vex = list.<span class="hljs-keyword">get</span>(i).charAt(list.<span class="hljs-keyword">get</span>(i).length() - <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">int</span> idx = locate(arr, vex);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ars[idx].length; j++) {
                            <span class="hljs-keyword">if</span> (ars[idx][j] &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 以邻接矩阵为线索</span>
                                list.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                            }
                        }
                    }
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">locate</span>(String[] arr, <span class="hljs-keyword">char</span> vex) {
        <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.length; k++) {
            <span class="hljs-keyword">if</span> (arr[k].equals(vex + <span class="hljs-string">""</span>)) {
                idx = k;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> idx;
    }
}</code></pre>
                    </div>
                </div>
                <p>那么，什么是<strong style="color: red;">邻接矩阵</strong>？直接看图：</p>
                <div style="margin-left: -20px; margin-right: 35px;">
                    <img alt="邻接矩阵" src="src/articles/02/02_2/images/0009_2.jpg" style="max-width: 100%; max-height: 100%;" />
                </div>
                <p style="word-wrap: break-word;"><strong style="color: red;">注意：</strong>由<strong style="color: red;">邻接矩阵</strong>也可以反推出测试数据：AB5，BC4，CD8，DC8，DE6，AD5，CE2，EB3，AE7。</p>
            </li>
            <li>
                <p>事实上，该题不必对<strong>有向图的所有结点</strong>进行排列且步骤 2 对<strong>有向图的所有结点</strong>的排列最多循环了 5 次也不尽合理，应该根据问题的具体描述以确定对<strong>有向图的某个结点</strong>进行相应次数的排列（可视之为<strong style="color: red;">广度优先搜索</strong>）。例如，根据该题第 6 问的描述，只需要对<strong>有向图的 C 结点</strong>进行排列即可且最多也只需要循环 4 次。于是，根据该题第 6 问的描述，步骤 2 的改进代码如下所示：</p>
                <div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
                    <h4>以邻接矩阵为线索对有向图的 C 结点进行排列实现：</h4>
                    <div class="w3-code" style="height: 300px; overflow-y: auto;">
                        <pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;
        <span class="hljs-keyword">int</span>[][] ars = { 
                { <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> } }; <span class="hljs-comment">// 邻接矩阵（adjacency-matrix）</span>

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
        <span class="hljs-comment">// 最终的结果集</span>
        List&lt;String&gt; rslt = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 根据该题第 6 问的描述，从 C 结点出发途经最多 2 站，所以有 K &lt; 4。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) {
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    <span class="hljs-comment">// 根据该题第 6 问的描述，只对有向图的 C 结点进行排列。</span>
                    <span class="hljs-keyword">if</span> (arr[i].equals(<span class="hljs-string">"C"</span>)) {
                        list.add(arr[i]);
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候（对<span style="color: red;">有向带环图</span>而言，可选择的排列字母是无穷个）</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).length() == k) {
                        <span class="hljs-keyword">char</span> vex = list.<span class="hljs-keyword">get</span>(i).charAt(list.<span class="hljs-keyword">get</span>(i).length() - <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">int</span> idx = locate(arr, vex);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ars[idx].length; j++) {
                            <span class="hljs-keyword">if</span> (ars[idx][j] &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 以邻接矩阵为线索</span>
                                list.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                                <span class="hljs-comment">// 根据该题第 6 问的描述，C 结点既为起点站又是终点站。</span>
                                <span class="hljs-keyword">if</span> (arr[j].equals(list.<span class="hljs-keyword">get</span>(i).charAt(<span class="hljs-number">0</span>) + <span class="hljs-string">""</span>)) {
                                    rslt.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                                }
                            }
                        }
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
                System.<span class="hljs-keyword">out</span>.println(rslt);
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">locate</span>(String[] arr, <span class="hljs-keyword">char</span> vex) {
        <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.length; k++) {
            <span class="hljs-keyword">if</span> (arr[k].equals(vex + <span class="hljs-string">""</span>)) {
                idx = k;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> idx;
    }
}</code></pre>
                    </div>
                </div>
            </li>
            <li>
                <p>在答出该题第 6 问之后，第 7 问也就迎刃而解。于是，根据该题第 7 问的描述，步骤 3 的改进代码如下所示：</p>
                <div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
                    <h4>以邻接矩阵为线索对有向图的 A 结点进行排列实现：</h4>
                    <div class="w3-code" style="height: 300px; overflow-y: auto;">
                        <pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;
        <span class="hljs-keyword">int</span>[][] ars = { 
                { <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> } }; <span class="hljs-comment">// 邻接矩阵（adjacency-matrix）</span>

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();
        <span class="hljs-comment">// 最终的结果集</span>
        List&lt;String&gt; rslt = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 根据该题第 7 问的描述，从 A 结点出发途经 3 站，所以有 K &lt; 5。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5</span>; k++) {
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    <span class="hljs-comment">// 根据该题第 7 问的描述，只对有向图的 A 结点进行排列。</span>
                    <span class="hljs-keyword">if</span> (arr[i].equals(<span class="hljs-string">"A"</span>)) {
                        list.add(arr[i]);
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候（对<span style="color: red;">有向带环图</span>而言，可选择的排列字母是无穷个）</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).length() == k) {
                        <span class="hljs-keyword">char</span> vex = list.<span class="hljs-keyword">get</span>(i).charAt(list.<span class="hljs-keyword">get</span>(i).length() - <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">int</span> idx = locate(arr, vex);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ars[idx].length; j++) {
                            <span class="hljs-keyword">if</span> (ars[idx][j] &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 以邻接矩阵为线索</span>
                                list.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                                <span class="hljs-comment">// 根据该题第 7 问的描述，A 结点为起点站而 C 结点是终点站且途经 3 站。</span>
                                <span class="hljs-keyword">if</span> ((list.<span class="hljs-keyword">get</span>(i) + arr[j]).endsWith(<span class="hljs-string">"C"</span>) &amp;&amp; (list.<span class="hljs-keyword">get</span>(i) + arr[j]).length() == <span class="hljs-number">5</span>) {
                                    rslt.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                                }
                            }
                        }
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
                System.<span class="hljs-keyword">out</span>.println(rslt);
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">locate</span>(String[] arr, <span class="hljs-keyword">char</span> vex) {
        <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.length; k++) {
            <span class="hljs-keyword">if</span> (arr[k].equals(vex + <span class="hljs-string">""</span>)) {
                idx = k;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> idx;
    }
}</code></pre>
                    </div>
                </div>
            </li>
            <li>
                <p>该题的第 10 问和第 6 问是相似的，只是在实现上对循环的终止条件不同，可见，只需在第 6 问的实现上对循环终止条件稍加变更就能够满足第 10 问的实现要求。于是，根据该题第 10 问的描述，步骤 3 的改进代码如下所示：</p>
                <div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
                    <h4>以邻接矩阵为线索对有向图的 C 结点进行排列实现：</h4>
                    <div class="w3-code" style="height: 300px; overflow-y: auto;">
                        <pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;
        <span class="hljs-keyword">int</span>[][] ars = { 
                { <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> } }; <span class="hljs-comment">// 邻接矩阵（adjacency-matrix）</span>

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;Route&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Route&gt;();
        <span class="hljs-comment">// 最终的结果集</span>
        List&lt;String&gt; rslt = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 该 for 循环的终止条件是 list 列表中不存在长度为 k 的字符串</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; !isEmpty(list, k); k++) {
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    <span class="hljs-comment">// 根据该题第 10 问的描述，只对有向图的 C 结点进行排列。</span>
                    <span class="hljs-keyword">if</span> (arr[i].equals(<span class="hljs-string">"C"</span>)) {
                        Route r = <span class="hljs-keyword">new</span> Route();
                        <span class="hljs-comment">// 初始化线路</span>
                        r.setRoute(arr[i]);
                        <span class="hljs-comment">// 初始化线路距离</span>
                        r.setDistance(ars[locate(arr, <span class="hljs-string">'C'</span>)][locate(arr, <span class="hljs-string">'C'</span>)]);
                        list.add(r);
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候（对<span style="color: red;">有向带环图</span>而言，可选择的排列字母是无穷个）</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).getRoute().length() == k) {
                        <span class="hljs-keyword">char</span> vex = list.<span class="hljs-keyword">get</span>(i).getRoute().charAt(list.<span class="hljs-keyword">get</span>(i).getRoute().length() - <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">int</span> idx = locate(arr, vex);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ars[idx].length; j++) {
                            <span class="hljs-keyword">if</span> (ars[idx][j] &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 以邻接矩阵为线索</span>
                                Route r = <span class="hljs-keyword">new</span> Route();
                                r.setRoute(list.<span class="hljs-keyword">get</span>(i).getRoute() + arr[j]);
                                r.setDistance(list.<span class="hljs-keyword">get</span>(i).getDistance() + ars[idx][j]);
                                <span class="hljs-keyword">if</span> (r.getDistance() &lt; <span class="hljs-number">30</span>) {
                                    list.add(r);
                                    <span class="hljs-keyword">if</span> (arr[j].equals(<span class="hljs-string">"C"</span>)) {
                                        rslt.add(r.getRoute());
                                    }
                                }
                            }
                        }
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
                System.<span class="hljs-keyword">out</span>.println(rslt);
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">locate</span>(String[] arr, <span class="hljs-keyword">char</span> vex) {
        <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.length; k++) {
            <span class="hljs-keyword">if</span> (arr[k].equals(vex + <span class="hljs-string">""</span>)) {
                idx = k;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> idx;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> boolean <span class="hljs-title">isEmpty</span>(List&lt;Route&gt; list, <span class="hljs-keyword">int</span> k) {
        boolean <span class="hljs-keyword">bool</span> = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">int</span> size = list.size();
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">bool</span> = <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).getRoute().length() == k) {
                    <span class="hljs-keyword">bool</span> = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>;
    }
}</code></pre>
                    </div>
                </div>
                <p>为了便于对循环终止条件的判断，在实现该题第 10 问时引入了新的 JAVA 类，代码如下所示：</p>
                <div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
                    <div class="w3-code" style="height: 300px; overflow-y: auto;">
                        <pre><code class="hljs">package com.study;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Route {

    <span class="hljs-keyword">private</span> String route; <span class="hljs-comment">// 表示线路</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> distance; <span class="hljs-comment">// 表示线路距离</span>

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getRoute</span>() {
        <span class="hljs-keyword">return</span> route;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoute</span>(String route) {
        <span class="hljs-keyword">this</span>.route = route;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDistance</span>() {
        <span class="hljs-keyword">return</span> distance;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDistance</span>(<span class="hljs-keyword">int</span> distance) {
        <span class="hljs-keyword">this</span>.distance = distance;
    }

}</code></pre>
                    </div>
                </div>
            </li>
            <li>
                <p>对有向赋权图而言，该题第 8 问和第 9 问可归结为求任意两点间的最短路径问题，闻名遐迩的<strong>迪杰斯特拉（Dijkstra）算法</strong>即是解决这类问题的经典算法，但是，为了体现博主对有向赋权图的相关问题的渐进式思考过程，个人觉得以基于排列的算法实现该题第 8 问和第 9 问比较符合由简入繁的原则。于是，根据该题第 8 问或第 9 问的描述，步骤 5 的改进代码如下所示：</p>
                <div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
                    <h4>算法思路：</h4>
                    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）找到两点间不包含“环”的所有可达路径；（2）求得路径长度最小值。</p>
                    <div class="w3-code" style="height: 300px; overflow-y: auto;">
						<pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;
        <span class="hljs-keyword">int</span>[][] ars = { 
                { <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span> }, 
                { <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> } }; <span class="hljs-comment">// 邻接矩阵（adjacency-matrix）</span>

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;Route&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Route&gt;();
        <span class="hljs-comment">// 最终的结果集</span>
        List&lt;String&gt; rslt = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 该 for 循环的终止条件是 list 列表中不存在长度为 k 的字符串</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; !isEmpty(list, k); k++) {
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    <span class="hljs-comment">// 根据该题第 8 问的描述，只对有向图的 A 结点进行排列。</span>
                    <span class="hljs-keyword">if</span> (arr[i].equals(<span class="hljs-string">"A"</span>)) {
                        Route r = <span class="hljs-keyword">new</span> Route();
                        <span class="hljs-comment">// 初始化线路</span>
                        r.setRoute(arr[i]);
                        <span class="hljs-comment">// 初始化线路距离</span>
                        r.setDistance(ars[locate(arr, <span class="hljs-string">'A'</span>)][locate(arr, <span class="hljs-string">'A'</span>)]);
                        list.add(r);
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候（对有向带环图而言，可选择的排列字母是无穷个）</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).getRoute().length() == k) {
                        <span class="hljs-keyword">char</span> vex = list.<span class="hljs-keyword">get</span>(i).getRoute().charAt(list.<span class="hljs-keyword">get</span>(i).getRoute().length() - <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">int</span> idx = locate(arr, vex);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ars[idx].length; j++) {
                            <span class="hljs-keyword">if</span> (ars[idx][j] &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// 以邻接矩阵为线索</span>
                                <span class="hljs-comment">// 由该题第 8 问的题意可知，求得路径不包含“环”。</span>
                                <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).getRoute().contains(arr[j])) {
                                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[j].equals(<span class="hljs-string">"C"</span>)) { <span class="hljs-comment">// 根据该题第 8 问的描述，终点站为 C 结点。</span>
                                    rslt.add(list.<span class="hljs-keyword">get</span>(i).getRoute() + arr[j] + <span class="hljs-string">","</span>
                                            + (list.<span class="hljs-keyword">get</span>(i).getDistance() + ars[idx][j]));
                                } <span class="hljs-keyword">else</span> {
                                    Route r = <span class="hljs-keyword">new</span> Route();
                                    r.setRoute(list.<span class="hljs-keyword">get</span>(i).getRoute() + arr[j]);
                                    r.setDistance(list.<span class="hljs-keyword">get</span>(i).getDistance() + ars[idx][j]);
                                    list.add(r);
                                }
                            }
                        }
                    }
                }
                <span class="hljs-comment">// System.out.println(list);</span>
                System.<span class="hljs-keyword">out</span>.println(rslt); <span class="hljs-comment">// 从结果集中得到最小路径即可</span>
            }
        }

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">locate</span>(String[] arr, <span class="hljs-keyword">char</span> vex) {
        <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.length; k++) {
            <span class="hljs-keyword">if</span> (arr[k].equals(vex + <span class="hljs-string">""</span>)) {
                idx = k;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> idx;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> boolean <span class="hljs-title">isEmpty</span>(List&lt;Route&gt; list, <span class="hljs-keyword">int</span> k) {
        boolean <span class="hljs-keyword">bool</span> = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">int</span> size = list.size();
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">bool</span> = <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).getRoute().length() == k) {
                    <span class="hljs-keyword">bool</span> = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>;
    }
}</code></pre>
                    </div>
                </div>
                <p><strong style="color: red;">注意：</strong>如要实现该题第 9 问，只需对上述代码稍加修改，博主就不再 coding 了。喜欢 coding 的童鞋就自己动手吧，勤于动手，丰衣足食。</p>
            </li>
        </ul>
    </div>
    <br>
	<br>
	<br>
	<a id="toggle-comment-box" class="w3-right" href="javascript:void(0);" onclick="toggleDuoshuoComments(event,'comment-box','02_02_2_0009');" style="color: #428bca; text-decoration: none;">展开评论</a>
	<a id="retract-comment-box" class="w3-right" href="javascript:void(0);" onclick="retractDuoshuoComments(event,'comment-box');" style="color: #428bca; text-decoration: none; display: none;">收起评论</a>
	<div id="comment-box"></div>
</article>