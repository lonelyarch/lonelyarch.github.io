<article>
	<header><h3>一个有关算法问题的思考过程</h3><h4 class="w3-right w3-margin-0"><i class="fa fa-calendar-o"></i> 2017-02-21</h4></header>
    <div style="clear: both;"></div>
    <hr style="margin-top: 0;">
    <div class="w3-panel w3-light-gray" style="border-radius: 10px;">
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近两天遇到一个比较棘手的算法问题，现给出问题的描述（原题为英文版）：</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Kiwiland 这个地方的城镇之间有铁路运营服务，出于经济考虑，所有的轨道都是“单向”的，例如，存在一条从 Kaitaia 到 Invercargill 运营线路不意味着一定会有一条从 Invercargill 到 Kaitaia 的运营线路，实际上，即使存在这样的往返线路，这两条线路也是相对独立的，例如，从 A 镇到 B 镇的线路长为 8，从 B 镇到 A 镇的线路长可能为 6。</p>
        <P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该问题的目的是帮助当地铁路部门向旅客们提供运营线路的相关信息，例如，一条确定线路的距离、两镇之间所有可达线路的总数以及两镇之间最短可达线路等。</P>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>输入：</strong>一个有向图，结点表示城镇，边表示两镇之间的运营线路，边权表示线路距离。给定的直达线路绝不重复且起点站与终点站不为同一城镇，即两镇之间的直达线路只有一条且表示城镇的结点无自环。</p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>输出：</strong>对测试题 1 至 5 而言，如果不存在这样的线路，输出 "NO SUCH ROUTE"，否则，给出线路距离。例如，第一个问题的意思是，以 A 城镇为起点站，途经 B 城镇（A、B 两镇的距离为 5）再抵达 C 城镇（B、C 两镇的距离为 4）。</p>
        <ul style="list-style-type: decimal; padding-left: 50px;">
            <li><p>线路 A-B-C 的距离。</p></li>
            <li><p>线路 A-D 的距离。</p></li>
            <li><p>线路 A-D-C 的距离。</p></li>
            <li><p>线路 A-E-B-C-D 的距离。</p></li>
            <li><p>线路 A-E-D 的距离。</p></li>
            <li><p>以 C 为起点站也为终点站（不含自环）且最多途经 2 站的所有线路总数。以下列测试数据为依据，有 2 条这样的线路：C-D-C（途经 D 站）和 C-E-B-C（途经 E、B 站）。</p></li>
            <li><p>以 A 为起点站、C 为终点站且途经 3 站的所有线路总数。以下列测试数据为依据，有 3 条这样的线路：A 到 C（途经 B、C、D 站）、A 到 C（途经 D、C、D 站）以及 A 到 C（途经 D、E、B 站）。</p></li>
            <li><p>A 至 C 的最短线路长。</p></li>
            <li><p>B 至 B 的最短线路长。</p></li>
            <li><p>C 至 C 的线路长少于 30 的所有不同线路数。以下列测试数据为依据，这些线路为：CDC, CEBC, CEBCDC, CDCEBC, CDEBC, CEBCEBC, CEBCEBCEBC。</p></li>
        </ul>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>测试输入：</strong></p>
    	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对测试输入而言，以字母表前几个字母 A 至 E 命名城镇，两镇之间的线路距离（例如，A 至 B 的距离为 5）用 AB5 表示。</p>
    	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图：AB5, BC4, CD8, DC8, DE6, AD5, CE2, EB3, AE7（<strong style="color: red;">测试数据</strong>）。如图所示：</p>
    	<img alt="赋权图" src="src/articles/02/02_2/images/0009_1.jpg" style="max-width: 100%; max-height: 100%; padding: 0 30px;" />
    	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;博主在看完题目之后最先想到的是在算法思想上妇孺皆知的<strong>迪杰斯特拉（Dijkstra）算法</strong>以及图论的相关内容，可惜，远离学生时代的几载春秋之后，它们的内在美于博主的记忆里已经是面目全非……</p>
    </div>
    <div class="w3-panel w3-custom-color" style="border-radius: 10px;">
    	<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对上述题目，博主用了几乎两天时间潜心复习了《数据结构》里图的相关知识，有向赋权图的概念、深度优先搜索、广度优先搜索以及迪杰斯特拉算法，可惜拙于天分，最终还是凭借强大的百度搜索解决了该题，不过，在几经烧脑之后，博主对该题有了新的算法实现，现记录一下自己的解题过程、想法以及答案：</p>
    	<ul style="list-style-type: decimal; padding-left: 50px;">
            <li>
            	<p>苦于良策久之，博主无意间想起了曾经解答过一个类似的含有邻接矩阵思想的问题，该问题考察的核心点就是用代码实现数学里的排列组合，现给出代码如下所示：</p>
            	<div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
            		<h3>对 A, B, C, D, E 进行排列实现：</h3>
					<div class="w3-code" style="height: 300px; overflow-y: auto;">
						<pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 排列：从 5 个数里选择 1 个字母、2 个字母、3 个字母、4 个字母、5 个字母</span>
        <span class="hljs-comment">// k 为选择字母的个数（编码习惯，没有将 k 初值设置为 1，即 k=0 表示选择 1 个字母，以此类推）</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) {
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    list.add(arr[i]);
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) {
                        <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).length() == k &amp;&amp; !list.<span class="hljs-keyword">get</span>(i).contains(arr[j])) {
                            <span class="hljs-comment">// 去重判断</span>
                            <span class="hljs-keyword">if</span> (list.contains(list.<span class="hljs-keyword">get</span>(i) + arr[j])) {
                                <span class="hljs-keyword">continue</span>;
                            }
                            list.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                        }
                    }
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            }
        }
    }
}</code></pre>
					</div>
				</div>
            </li>
            <li>
            	<p>在实现 A, B, C, D, E 的全排列之后，对上述代码稍加修改就可对有向图<strong style="color: red;">以邻接矩阵为线索</strong>进行全排列（可视之为<strong style="color: red;">广度优先搜索</strong>），修改之后的代码如下所示：</p>
            	<div class="w3-example" style="margin-left: -20px; margin-right: 35px;">
            		<h3>以邻接矩阵为线索对有向图进行排列实现：</h3>
					<div class="w3-code" style="height: 300px; overflow-y: auto;">
						<pre><code class="hljs">package com.study;

import java.util.ArrayList;
import java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> MainClass {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {

        String[] arr = { <span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span> };
        <span class="hljs-keyword">int</span> len = arr.length;
        <span class="hljs-keyword">int</span>[][] ars = {
                {<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>},
                {<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}}; <span class="hljs-comment">// 邻接矩阵（adjacency-matrix）</span>

        <span class="hljs-comment">// 排列的结果集</span>
        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();

        <span class="hljs-comment">// 排列：从 5 个数里选择 1 个字母、2 个字母、3 个字母、4 个字母、5 个字母</span>
        <span class="hljs-comment">// k 为选择字母的个数（编码习惯，没有将 k 初值设置为 1，即 k=0 表示选择 1 个字母，以此类推）</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++) { 
            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) { <span class="hljs-comment">// 选择 1 个字母进行排列的时候</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    list.add(arr[i]);
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 选择多个字母进行排列的时候</span>
                <span class="hljs-keyword">int</span> size = list.size();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
                    <span class="hljs-keyword">if</span> (list.<span class="hljs-keyword">get</span>(i).length() == k) {
                        <span class="hljs-keyword">char</span> vex = list.<span class="hljs-keyword">get</span>(i).charAt(list.<span class="hljs-keyword">get</span>(i).length() - <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">int</span> idx = locate(arr, vex);
                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ars[idx].length; j++) {
                            <span class="hljs-keyword">if</span> (ars[idx][j] &gt; <span class="hljs-number">0</span>) {
                                list.add(list.<span class="hljs-keyword">get</span>(i) + arr[j]);
                            }
                        }
                    }
                }
                System.<span class="hljs-keyword">out</span>.println(list);
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">locate</span>(String[] arr, <span class="hljs-keyword">char</span> vex) {
        <span class="hljs-keyword">int</span> idx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.length; k++) {
            <span class="hljs-keyword">if</span> (arr[k].equals(vex + <span class="hljs-string">""</span>)) {
                idx = k;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">return</span> idx;
    }
}</code></pre>
					</div>
				</div>
				<p>那么，什么是<strong style="color: red;">邻接矩阵</strong>？直接看图：</p>
				<div style="margin-left: -20px; margin-right: 35px;">
					<img alt="邻接矩阵" src="src/articles/02/02_2/images/0009_2.jpg" style="max-width: 100%; max-height: 100%;" />
				</div>
            	<p><strong style="color: red;">注意：</strong>由<strong style="color: red;">邻接矩阵</strong>也可以反推出测试数据：AB5, BC4, CD8, DC8, DE6, AD5, CE2, EB3, AE7。</p>
            </li>
            <li><p>事实上，该题不必对所有<strong>有向图结点</strong>进行排列且步骤 2 对<strong>有向图的所有结点</strong>的排列最多循环了 5 次也是不合理的，应该根据问题的具体描述以确定对<strong>有向图的某个结点</strong>进行相应次数的排序（可视之为<strong style="color: red;">广度优先搜索</strong>）。例如，根据该题第 6 问的描述，只需要对<strong>有向图的 C 结点</strong>进行排列即可且最多也只需要循环 4 次，根据该题第 10 问的描述，需要对<strong style="color: red;">相应权值累加之后的和</strong>进行判断以终止循环。</p></li>
        </ul>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;待续……</p>
    </div>
</article>